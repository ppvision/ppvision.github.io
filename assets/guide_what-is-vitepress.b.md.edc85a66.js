import{_ as e}from"./chunks/Xfunctions.3f1e9182.js";import{_ as t,o as a,c as i,Q as r}from"./chunks/framework.ffb2c379.js";const b=JSON.parse('{"title":"PicXTools 是什么?","description":"","frontmatter":{},"headers":[],"relativePath":"guide/what-is-vitepress.b.md","filePath":"guide/what-is-vitepress.b.md","lastUpdated":null}'),s={name:"guide/what-is-vitepress.b.md"},o=r('<h1 id="picxtools-是什么" tabindex="-1">PicXTools 是什么? <a class="header-anchor" href="#picxtools-是什么" aria-label="Permalink to &quot;PicXTools 是什么?&quot;">​</a></h1><p>PicXTools是基于树莓派rp2040的嵌入式开发工具,它很好的解决了嵌入式开发人员开发流程中遇到的一些痛点。比如在模组开发、多CPU/多板间通信开发，开发人员可能需要多套调试器、串口模块:</p><ul><li><strong>更多的USB端口来连接调试工具；因此你可能需要额外的USB HUB。</strong></li><li><strong>更多的杜邦线连接开发板</strong></li><li><strong>昂贵的调试器(如J-LINK)你可能需要配置多个</strong></li></ul><p>PicXTools可以很好的解决了这些痛点。</p><h2 id="功能图-硬件资源" tabindex="-1">功能图&amp;硬件资源 <a class="header-anchor" href="#功能图-硬件资源" aria-label="Permalink to &quot;功能图&amp;硬件资源&quot;">​</a></h2><p><img src="'+e+'" alt=""></p><ul><li><strong>JLink 转接器</strong> 提供了标准20针Jlink接口（母）可以直接插入JLink调试器无需另外的排线。并进行了如下的扩展 <ul><li>模拟开关(双刀4掷)对cJTAG/SWD接口实现1拖4.</li><li>通过拨盘或API接口可对四目标设备进行选择调试；无需插拔排线。</li></ul><div class="tip custom-block" style="padding-top:8px;"><h4>注意</h4><ul><li>当插入外接JLINK时(通过JLink第二脚的VCC 高电平来判断）PicoXTools的四路 SWD/cJTAGE 引脚会路由到外部的JLINK，而不是PicXTools的Dap-Link.</li><li>因为是双刀模拟开关，JLink的一拖四接口仅支持SWD/cJTAGE信号</li></ul></div></li></ul><h2 id="调试器-仿真器" tabindex="-1"><strong>调试器/仿真器</strong> <a class="header-anchor" href="#调试器-仿真器" aria-label="Permalink to &quot;**调试器/仿真器**&quot;">​</a></h2><p>调试器和仿真器用于连接到目标嵌入式系统，以便实时监视程序的执行和内部状态。通过这些工具，工程师可以进行代码单步执行、变量查看和硬件寄存器调试等。常用的调试器有：</p><ul><li>Segger J-Link</li><li>ST-Link</li><li>Black Magic Probe</li><li>DAP-Link</li></ul><div class="tip custom-block" style="padding-top:8px;"><h4>高速DAP-Link</h4> 其于树莓派官方实现的DAP-Link（pic-proble） 可以用来调试RP2040本身，结合open-ocd可以调试更多种类的MCU。借助于rp2040高效的PIO，SWD的时钟可以到数十兆（具体速度受限于连接的MCU支持的最大时钟，ARM公司给出的建议是不大于其主频的 6 分之一）。PicXTools调试另一块PicXTools板子 SWD 的速度可达到20+M </div><h2 id="串口工具" tabindex="-1"><strong>串口工具</strong> <a class="header-anchor" href="#串口工具" aria-label="Permalink to &quot;**串口工具**&quot;">​</a></h2><p>将调试信息（例如变量值、状态信息、错误消息等）通过串口发送到主机。这些信息将帮助工程师了解嵌入式系统的运行状态和问题。（串口调试在嵌入式系统开发中是一种比较基础的调试方法。在实际的应用中，可能会使用更高级的调试工具和方法，例如使用调试器连接到目标板进行硬件级别的调试，或者使用RTT（Real-Time Transfer）等更高级的调试技术。目前主流usb转ttl芯片为cp210x 与沁恒居多。</p><div class="tip custom-block" style="padding-top:8px;"><h4>4路硬件USB转TTL</h4><span>rp2040本身包含两路UART可以通过PIO可以模拟更多的UART，但PicXTools仍包含独立的4路硬件USB转TTL(芯片为CH344Q)。 CH344Q连接于内部的USB HUB</span><ul><li>CH344Q为480Mbps高速USB设备接口</li><li>支持免安装的操作系统内置CDC类驱动程序或者多功能高速率的VCP厂商驱动程序</li><li>硬件全双工串口，内置独立的收发缓冲区</li><li>CH344Q支持通讯波特率1200bps～6Mbps</li><li>每个串口内置1024字节的接收FIFO，512字节的发送FIFO</li></ul></div><h2 id="usb-hub" tabindex="-1"><strong>USB HUB</strong> <a class="header-anchor" href="#usb-hub" aria-label="Permalink to &quot;**USB HUB**&quot;">​</a></h2><p>PicXTools提供了1转4的USB HUB。其中两路分别连接rp2040与 CH344q 另外两路可供开发人员使用，接口为type-C <div class="tip custom-block" style="padding-top:8px;"> USB HUB 自带Reset按钮，如需重新枚举USB设备只需按下Reset按钮，无需插拔usb设备，带来了极大的便利。 </div></p><h2 id="arm开发板" tabindex="-1"><strong>Arm开发板</strong> <a class="header-anchor" href="#arm开发板" aria-label="Permalink to &quot;**Arm开发板**&quot;">​</a></h2><p>PicXTools其本身也是一块资源丰富的开发板其基于树梅派RP2040具有优异的性能，良好的社区环境。</p><div class="tip custom-block" style="padding-top:8px;"><ul><li>0.96寸LCD 屏幕，LVGL已经Ready!</li><li>16MB QSPI Flash</li><li>存储器：它内置264KB的SRAM</li><li>双核m0+的内核，可以运于133Mh+，超频后可稳定运行于266M</li><li>RP2040带有USB PHY，可以同时作为USB主机或USB设备，TinyUSB 良好的移植</li><li>PIO（Programmable Input/Output）可以模拟多种外设如 i2s、eth mac 、vga,hdmi等专有外设,类似FPGA的功能。</li><li>极好的社区支持、有大量的极客基于其开发出一些有趣的项目如：示波器、逻辑分析仪等</li></ul></div><h2 id="电源ry1303" tabindex="-1"><strong>电源RY1303</strong> <a class="header-anchor" href="#电源ry1303" aria-label="Permalink to &quot;**电源RY1303**&quot;">​</a></h2><p>PicXTools供电采用一颗RY1303将VBUS转为3路3.3V，</p><ul><li>一路为rp2040、CH344q核心供电；</li><li>一路为4路UART外设供电，</li><li>另外一路为扩展板供电。</li></ul><p>外设的供电可以通过gpio的引脚控制。</p><h2 id="use-cases" tabindex="-1">Use Cases <a class="header-anchor" href="#use-cases" aria-label="Permalink to &quot;Use Cases&quot;">​</a></h2><ul><li><p><strong>Documentation</strong></p><p>VitePress ships with a default theme designed for technical documentation. It powers this page you are reading right now, along with the documentation for <a href="https://vitejs.dev/" target="_blank" rel="noreferrer">Vite</a>, <a href="https://rollupjs.org/" target="_blank" rel="noreferrer">Rollup</a>, <a href="https://pinia.vuejs.org/" target="_blank" rel="noreferrer">Pinia</a>, <a href="https://vueuse.org/" target="_blank" rel="noreferrer">VueUse</a>, <a href="https://vitest.dev/" target="_blank" rel="noreferrer">Vitest</a>, <a href="https://d3js.org/" target="_blank" rel="noreferrer">D3</a>, <a href="https://unocss.dev/" target="_blank" rel="noreferrer">UnoCSS</a>, <a href="https://iconify.design/" target="_blank" rel="noreferrer">Iconify</a> and <a href="https://www.vuetelescope.com/explore?framework.slug=vitepress" target="_blank" rel="noreferrer">many more</a>.</p><p>The <a href="https://vuejs.org/" target="_blank" rel="noreferrer">official Vue.js documentation</a> is also based on VitePress, but uses a custom theme shared between multiple translations.</p></li><li><p><strong>Blogs, Portfolios, and Marketing Sites</strong></p><p>VitePress supports <a href="./custom-theme">fully customized themes</a>, with the developer experience of a standard Vite + Vue application. Being built on Vite also means you can directly leverage Vite plugins from its rich ecosystem. In addition, VitePress provides flexible APIs to <a href="./data-loading">load data</a> (local or remote) and <a href="./routing#dynamic-routes">dynamically generate routes</a>. You can use it to build almost anything as long as the data can be determined at build time.</p><p>The official <a href="https://blog.vuejs.org/" target="_blank" rel="noreferrer">Vue.js blog</a> is a simple blog that generates its index page based on local content.</p></li></ul><h2 id="developer-experience" tabindex="-1">Developer Experience <a class="header-anchor" href="#developer-experience" aria-label="Permalink to &quot;Developer Experience&quot;">​</a></h2><p>VitePress aims to provide a great Developer Experience (DX) when working with Markdown content.</p><ul><li><p><strong><a href="https://vitejs.dev/" target="_blank" rel="noreferrer">Vite-Powered:</a></strong> instant server start, with edits always instantly reflected (&lt;100ms) without page reload.</p></li><li><p><strong><a href="./markdown">Built-in Markdown Extensions:</a></strong> Frontmatter, tables, syntax highlighting... you name it. Specifically, VitePress provides many advanced features for working with code blocks, making it ideal for highly technical documentation.</p></li><li><p><strong><a href="./using-vue">Vue-Enhanced Markdown:</a></strong> each Markdown page is also a Vue <a href="https://vuejs.org/guide/scaling-up/sfc.html" target="_blank" rel="noreferrer">Single-File Component</a>, thanks to Vue template&#39;s 100% syntax compatibility with HTML. You can embed interactivity in your static content using Vue templating features or imported Vue components.</p></li></ul><h2 id="performance" tabindex="-1">Performance <a class="header-anchor" href="#performance" aria-label="Permalink to &quot;Performance&quot;">​</a></h2><p>Unlike many traditional SSGs, a website generated by VitePress is in fact a <a href="https://en.wikipedia.org/wiki/Single-page_application" target="_blank" rel="noreferrer">Single Page Application</a> (SPA).</p><ul><li><p><strong>Fast Initial Load</strong></p><p>The initial visit to any page will be served the static, pre-rendered HTML for blazing fast loading speed and optimal SEO. The page then loads a JavaScript bundle that turns the page into a Vue SPA (&quot;hydration&quot;). The hydration process is extremely fast: on <a href="https://pagespeed.web.dev/report?url=https%3A%2F%2Fvitepress.dev%2F" target="_blank" rel="noreferrer">PageSpeed Insights</a>, typical VitePress sites achieve near-perfect performance scores even on low-end mobile devices with a slow network.</p></li><li><p><strong>Fast Post-load Navigation</strong></p><p>More importantly, the SPA model leads to better user experience <strong>after</strong> the initial load. Subsequent navigation within the site will no longer cause a full page reload. Instead, the incoming page&#39;s content will be fetched and dynamically updated. VitePress also automatically pre-fetches page chunks for links that are within viewport. In most cases, post-load navigation will feel instant.</p></li><li><p><strong>Interactivity Without Penalty</strong></p><p>To be able to hydrate the dynamic Vue parts embedded inside static Markdown, each Markdown page is processed as a Vue component and compiled into JavaScript. This may sound inefficient, but the Vue compiler is smart enough to separate the static and dynamic parts, minimizing both the hydration cost and payload size. For the initial page load, the static parts are automatically eliminated from the JavaScript payload and skipped during hydration.</p></li></ul><h2 id="what-about-vuepress" tabindex="-1">What About VuePress? <a class="header-anchor" href="#what-about-vuepress" aria-label="Permalink to &quot;What About VuePress?&quot;">​</a></h2><p>VitePress is the spiritual successor of VuePress. The original VuePress was based on Vue 2 and webpack. With Vue 3 and Vite under the hood, VitePress provides significantly better DX, better production performance, a more polished default theme, and a more flexible customization API.</p><p>The API difference between VitePress and VuePress mostly lies in theming and customization. If you are using VuePress 1 with the default theme, it should be relatively straightforward to migrate to VitePress.</p><p>There has also been effort invested into VuePress 2, which also supports Vue 3 and Vite with more compatibility with VuePress 1. However, maintaining two SSGs in parallel isn&#39;t sustainable, so the Vue team has decided to focus on VitePress as the main recommended SSG in the long run.</p>',35),l=[o];function n(p,d,h,c,u,g){return a(),i("div",null,l)}const P=t(s,[["render",n]]);export{b as __pageData,P as default};
